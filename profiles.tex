\chapter{Profiles}
\label{profiles}

\section{General principles}
Generally, a profile defines information specific to a certain `type' of system -- it lies somewhere
between repository-level defaults and user configuration in that the information it contains is not
necessarily applicable to all machines, but is sufficiently general that it should not be left to
the user to configure it. Some parts of the profile can be overridden by user configuration, some
only by another profile.

The format of a profile is relatively simple. Each profile is a directory containing any number of
the files described in this chapter, and possibly inheriting another profile. The files themselves
follow a few basic conventions as regards inheritance and format; these are described in the next
section. It may also contain any number of subdirectories containing other profiles.

\section{Files that make up a profile}
\subsection{The parent file}
A profile may contain a \t{parent} file. This must contain, on its first line, the relative path to
another profile which will be considered as this profile's parent. Any settings from the parent are
inherited by this profile, and can be overridden by it. Precise rules for how settings are combined
with the parent profile vary between files, and are described below.

\subsection{deprecated}
If a profile contains a file named \t{deprecated}, it is treated as such. The first line of this
file should contain the path from the \t{profiles} directory of the repository to a valid profile
that is the recommended upgrade path from this profile. The remainder of the file can contain any
text, which may be displayed to users using this profile by the package manager. This file is not
inherited -- profiles which inherit from a deprecated profile are \e{not} deprecated.

\subsection{make.defaults}
\t{make.defaults} is used to define defaults for various environment and configuration variables.
This file is unusual in that it is not combined at a file level with the parent -- instead, each
variable is combined or overridden individually as described in section \ref{profile-variables}.

The file itself is a line-based key-value format. Each line contains a single \verb|VAR="value"|
entry. Additional syntax, which is a small subset of bash syntax, is allowed as follows:

\begin{bulletlist}
\item Variables inside double-quoted strings in the form \t{\$\{foo\}} or \t{\$foo} are recognised and
  expanded from variables previously set in this or earlier \t{make.defaults} files.
\item One logical line may be continued over multiple physical lines by escaping the newline with a
  backslash. This is also permitted inside quoted strings.
\end{bulletlist}

\subsection{virtuals}
\label{profiles-virtuals}
The \t{virtuals} file defines default providers for ``old-style'' virtual packages. It is a simple
line-based file, with each line containing two whitespace-delimited tokens. The first is a virtual
package name (for example, \t{virtual/alsa}) and the second is a qualified package name. Blank lines
and those beginning with a \# character are ignored. When attempting to resolve a virtual name to a
concrete package, the atom defined in the active profile's \t{virtuals} list should be used if no
provider is already installed.

The \t{virtuals} file is inherited in the simplest manner: all entries from the parent profile are
loaded, then entries from the current profile. If a virtual package name appears in both, the entry
in the parent profile is discarded.

\subsection{use.defaults}
The \t{use.defaults} file is used to implement `autouse' -- switching USE flags on or off depending
upon which packages are installed. It is considered deprecated, and is not used by default by any
current package manager. It is mentioned here for completeness only, and its format is not
discussed.

\subsection{Simple line-based files}
\label{line-stacking}
These files are a simple one-item-per-line list, which is inherited in the following manner: the
parent profile's list is taken, and the current profile's list appended. If any line begins with a
hyphen, then any lines previous to it whose contents are equal to the remainder of that line are
removed from the list. Once again, blank lines and those beginning with a \# are discarded.

\subsection{packages}
The \t{packages} is used to define the `system set' for this profile. After the above rules for
inheritance and comments are applied, its lines should take one of two forms: a dependency atom
prefixed by \t{*} denotes that the atom forms part of the system set. A dependency atom on its own
may also appear for legacy reasons, but should be ignored when calculating the system set.

\subsection{packages.build}
The \t{packages.build} file is used by Gentoo's Catalyst tool to generate stage1 tarballs, and has
no relevance to the operation of a package manager. It is thus outside the scope of this document,
but is mentioned here for completeness.

\subsection{package.mask}
\t{package.mask} is used to prevent packages from being installed on a given profile. Each line
contains one dep atom; anything matching this atom will not be installed unless unmasked by the
user's configuration.

Note that the \t{-atom} syntax can be used to remove a mask in a parent profile, but not
necessarily a global mask (from \t{profiles/package.mask}, section \ref{profiles-package.mask}).

\TODO{Portage has rather weird behaviour on \t{profiles/package.mask}. It treats it as being
   at the leftmost branch of the inherit tree for purposes of removing items. This is rather
   icky. Is it safe to require proper separation between the two types of \t{package.mask}?}

\subsection{package.provided}
\t{package.provided} is used to tell the package manager that a certain package version should be
considered to be provided by the system regardless of whether it is actually installed. Because it
has severe adverse effects on USE-based and slot-based dependencies, its use is strongly deprecated
and package manager support should be regarded as purely optional.

\subsection{USE masking and forcing}
\label{use-masking}
This section covers the four files \t{use.mask}, \t{use.force}, \t{package.use.mask} and
\t{package.use.force}. They are described together because they interact in a non-trivial manner.

Simply speaking, \t{use.mask} and \t{use.force} are used to say that a given USE flag must never or
always, respectively, be enabled when using this profile. \t{package.use.mask} and
\t{package.use.force} do the same thing on a per-package, or per-version, basis. The precise manner
in which they interact is less simple, and is best described in terms of the algorithm used to
determine whether a flag is masked for a given package version. This is described in Algorithm
\ref{alg:use-masking}.
\begin{algorithm}
\caption{USE masking logic} \label{alg:use-masking}
\begin{algorithmic}[1]
\STATE let masked = false
\FOR{each profile in the inheritance stack, ending with the current one}
    \IF{\t{use.mask} contains \i{flag}}
        \STATE let masked = true
    \ELSIF{\t{use.mask} contains \i{-flag}}
        \STATE let masked = false
    \ENDIF
    \FOR{each $line$ in package.use.mask, in order, for which the atom matches $package$}
        \IF{$line$ contains \i{flag}}
            \STATE let masked = true
        \ELSIF{$line$ contains \i{-flag}}
            \STATE let masked = false
        \ENDIF
    \ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

The logic for \t{use.force} and \t{package.use.force} is identical. If a flag is both masked and
forced, the mask is considered to take precedence.

\input{profile-variables.tex}

% vim: set filetype=tex fileencoding=utf8 et tw=100 spell spelllang=en :
